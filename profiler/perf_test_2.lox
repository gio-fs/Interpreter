{
    print "=== Test 1: Deep Object Graph ===";
    class Node {
        init(value) {
            this.value = value;
            this.left = nil;
            this.right = nil;
            this.parent = nil;
            this.data = {};
            this.metadata = [];
        }
    }

    var start = clock();

    // Build binary tree with 10K nodes
    var root = Node(0);
    var nodes = [root];

    for i in [1..10000] {
        var node = Node(i);
        var parent = nodes.get((i - 1) / 2);
        var left = 0;
        var right = 0;

        if (left == right) {
            parent.right = node;
            right = right + 1;
        } else {
            parent.left = node;
            left = left + 1;
        }

        node.parent = parent;

        // Add metadata to stress GC
        for j in [1..10] {
            node.metadata.add({"id": j, "value": i * j});
        }

        node.data.add("index", i);
        node.data.add("depth", i / 2);
        node.data.add("hash", "node_" + i);

        nodes.add(node);
    }

    // Deep traversal to test old gen scanning
    var sum = 0;
    for node in nodes {
        sum = sum + node.value;

        if (node.left != nil) {
            sum = sum + node.left.value;
        }

        if (node.right != nil) {
            sum = sum + node.right.value;
        }

        for meta in node.metadata {
            sum = sum + meta.get("value");
        }
    }

    var end = clock();
    print "Deep graph: ${end-start}s, sum: ${sum}";
}

// ============================================================================
// TEST 2: Rapid Allocation and Collection (Young Gen Stress)
// Tests: Minor GC frequency, nursery evacuation, allocation speed
// ============================================================================
{
    print "\n=== Test 2: Rapid Allocation ===";

    var start = clock();
    var survivors = [];

    for round in [1..1000] {
        var batch = [];
        var count = 0;
        var k = 1;
        var j = 1;

        // Create many short-lived objects
        for i in [1..500] {
            var temp = {
                "id": i,
                "round": round,
                "data": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
            };
            count = count + 1;

            // Most die immediately
            if (count == 50 * k) {
                batch.add(temp);
                k = k + 1;
            }
        }

        // Few survive
        if (count == 100 * j) {
            survivors.add(batch);
            j = j + 1;
        }
    }

    var total = 0;
    for batch in survivors {
        for item in batch {
            total = total + item.get("id");
        }
    }

    var end = clock();
    print "Rapid allocation: ${end-start}s, total: ${total}";
}

// ============================================================================
// TEST 3: String Interning Stress
// Tests: String table, hash collisions, interning performance
// ============================================================================
{
    print "\n=== Test 3: String Interning ===";

    var start = clock();
    var strings = {};
    var keys = [];

    // Create many unique strings
    for i in [1..50000] {
        var key = "key_" + i + "_suffix_" + (i * 2);
        keys.add(key);

        var value = "value_" + i + "_data_" + (i * 3);
        strings.add(key, value);
    }

    // Access with string concatenation (tests interning)
    var sum = 0;
    for i in [1..50000] {
        var lookupKey = "key_" + i + "_suffix_" + (i * 2);
        var val = strings.get(lookupKey);

        if (val != nil) {
            sum = sum + 1;
        }
    }

    var end = clock();
    print "String interning: ${end-start}s, lookups: ${sum}";
}

// ============================================================================
// TEST 4: Circular References (GC Correctness Test)
// Tests: Cycle detection, proper marking, no premature collection
// ============================================================================
{
    print "\n=== Test 4: Circular References ===";

    class ListNode {
        init(value) {
            this.value = value;
            this.next = nil;
            this.prev = nil;
            this.cycle = nil;
        }
    }

    var start = clock();

    // Create circular linked lists
    var lists = [];
    for listId in [1..5000] {
        var head = ListNode(listId * 1000);
        var current = head;

        // Build list with 100 nodes
        for i in [1..100] {
            var node = ListNode(listId * 1000 + i);
            current.next = node;
            node.prev = current;
            current = node;
        }

        // Create cycle
        current.next = head;
        head.prev = current;

        // Add cross-list reference
        if (listId > 1) {
            head.cycle = lists.get(listId - 2);
        }

        lists.add(head);
    }

    // Traverse and break cycles
    var sum = 0;
    for head in lists {
        var current = head;
        var count = 0;

        for i in [1..1000] {
            sum = sum + current.value;
            current = current.next;
            count = count + 1;
        }
    }

    var end = clock();
    print "Circular refs: ${end-start}s, sum: ${sum}";
}

// ============================================================================
// TEST 5: Hash Table Stress (Collision and Resize)
// Tests: Hash table operations, resizing, collision handling
// ============================================================================
{
    print "\n=== Test 5: Hash Table Stress ===";

    var start = clock();

    var mainTable = {};

    // Fill with many entries to force resizing
    for i in [1..10000] {
        var key = "k" + i;
        var nestedTable = {};

        for j in [1..200] {
            nestedTable.add("field" + j, i * j);
        }

        mainTable.add(key, nestedTable);
    }

    // Random access pattern
    var sum = 0;
    for i in [1..10000] {
        var idx = rand(1, 10000);
        var key = "k" + idx;
        var nested = mainTable.get(key);

        if (nested != nil) {
            var val = nested.get("field10");
            if (val != nil) {
                sum = sum + val;
            }
        }
    }

    // Delete half
    for i in [1..50000] {
        var key = "k" + (i * 2);
        mainTable.add(key, nil);
    }

    var end = clock();
    print "Hash table stress: ${end-start}s, sum: ${sum}";
}

// ============================================================================
// TEST 6: Array Operations (Growth and Compaction)
// Tests: Array reallocation, copying, memory usage
// ============================================================================
{
    print "\n=== Test 6: Array Operations ===";

    var start = clock();

    var arrays = [];

    // Create many arrays with different sizes
    for i in [1..1000] {
        var arr = [];

        // Variable size arrays
        var size = rand (50, 2000);
        for j in [1..size] {
            arr.add({"idx": j, "val": i * j});
        }

        arrays.add(arr);
    }

    // Nested iteration (tests GC during array access)
    var sum = 0;
    for outerArr in arrays {
        for item in outerArr {
            sum = sum + item.get("val");

            // Create temporary arrays
            var temp = [];
            for k in [1..100] {
                temp.add(k);
            }
        }
    }

    var end = clock();
    print "Array operations: ${end-start}s, sum: ${sum}";
}





